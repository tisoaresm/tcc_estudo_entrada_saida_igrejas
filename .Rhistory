# Criar o plot
p <- ggplot(dados_merged) +
geom_sf(aes(fill = predominante), color = "white", size = 0.1) +
scale_fill_manual(values = c("Evangelical" = "lightblue",
"Mainline" = "lightgreen",
"Católica" = "pink",
"Empate" = "gray")) +
coord_sf(xlim = lim_lon, ylim = lim_lat) +
labs(title = paste("Denominação Predominante em", ano),
fill = "Denominação") +
theme_minimal()
# Salvar o plot
ggsave(filename = file.path(output_dir, paste("mapa_categoria_dominante_", ano, ".png", sep = "")),
plot = p, width = 8, height = 6)
}
output_directory <- "figuras"
# Definir limites dos EUA (ajustar se necessário)
lim_lat <- c(24, 50)
lim_lon <- c(-125, -66)
# Gerar os mapas para os anos de interesse
anos <- c(1980, 1990, 2000, 2010)
for (ano in anos) {
plot_map(dados_condados_pivot, mapa_condados, ano, lim_lat, lim_lon)
}
############# DELETAR
#
# # Agrupar por condado e ano, e somar o número de templos
# dados_condados <- dados %>%
#   group_by(fipsmerg, year) %>%
#   summarize(total_templos = sum(congreg, na.rm = TRUE)) %>%
#   ungroup()
# # View(dados_condados)
# # dados_condados
# # write_xlsx(dados_condados, "outputs\\dados_condados.xlsx")
#
# # total_min <- min(dados_condados$total_templos, na.rm = TRUE)
# # total_max <- max(dados_condados$total_templos, na.rm = TRUE)
# total_min <- quantile(dados_condados$total_templos, 0.05, na.rm = TRUE)
# total_max <- quantile(dados_condados$total_templos, 0.95, na.rm = TRUE)
#
# # Truncando os valores da coluna 'total_templos' para ficar dentro dos percentis
# dados_condados <- dados_condados %>%
#   mutate(total_templos_ajustado = pmin(pmax(total_templos, total_min), total_max))
#
#
# # Definindo a função plot_map
# plot_map <- function(data, ano, shapefile, output_dir) {
#   # Filtrando os dados para o ano específico
#   dados_ano <- data %>% filter(year == ano)
#
#   # Unindo os dados de templos com o shapefile
#   mapa_dados <- shapefile %>%
#     left_join(dados_ano, by = c("GEOID" = "fipsmerg"))
#
#   # Verificando se a junção retornou dados
#   if (nrow(mapa_dados) == 0) {
#     warning(paste("Nenhum dado encontrado para o ano", ano))
#     return(NULL)  # Encerra a função se não houver dados
#   }
#
#   # Criando o mapa
#   mapa <- ggplot(data = mapa_dados) +
#     geom_sf(aes(fill = total_templos_ajustado)) +  # Preenchimento baseado na soma de templos
#     scale_fill_viridis_c(option = "plasma", na.value = "grey50",
#                          limits = c(total_min, total_max)) +  # Paleta de cores
#     labs(title = paste("Total de Templos por Condado - Ano", ano),
#          fill = "Total de Templos") +
#     coord_sf(xlim = c(-125, -65), ylim = c(25, 50), expand = FALSE) +  # Definindo os limites para focar nos EUA
#     theme_minimal()
#
#   print(mapa)
#
#   # Salvando o plot como PNG
#   ggsave(filename = file.path(output_dir, paste("mapa_tempos_", ano, ".png", sep = "")),
#          plot = mapa,
#          width = 10, height = 8, dpi = 300)
# }
#
# anos_unicos <- unique(dados_condados$year)  # Obtendo anos únicos
# output_directory <- "figuras"
#
# # Criando o diretório se não existir
# if (!dir.exists(output_directory)) {
#   dir.create(output_directory)
# }
#
# # Gerando e salvando mapas para cada ano
# for (ano in anos_unicos) {
#   resultado <- plot_map(dados_condados, ano, mapa_condados, output_directory)
#
#   # Verifica se o resultado é NULL e informa ao usuário
#   if (is.null(resultado)) {
#     message(paste("Nenhum mapa gerado para o ano:", ano))
#   }
# }
#
# ### PARA UM ESTADO ESPECIFICO
#
# # Definindo a função plot_map com filtragem por estado
# plot_map <- function(data, ano, shapefile, output_dir, total_min, total_max, fips_estado) {
#   # Filtrando os dados para o ano específico
#   dados_ano <- data %>% filter(year == ano)
#
#   # Filtrando o shapefile e os dados para o estado específico com base nos dois primeiros dígitos do código FIPS
#   shapefile_estado <- shapefile %>% filter(substr(GEOID, 1, 2) == fips_estado)
#   dados_ano_estado <- dados_ano %>% filter(substr(fipsmerg, 1, 2) == fips_estado)
#
#   # Unindo os dados de templos com o shapefile do estado
#   mapa_dados <- shapefile_estado %>%
#     left_join(dados_ano_estado, by = c("GEOID" = "fipsmerg"))
#
#   # Verificando se a junção retornou dados
#   if (nrow(mapa_dados) == 0) {
#     warning(paste("Nenhum dado encontrado para o ano", ano))
#     return(NULL)  # Encerra a função se não houver dados
#   }
#
#   # Criando o mapa focado no estado específico
#   mapa <- ggplot(data = mapa_dados) +
#     geom_sf(aes(fill = total_templos_ajustado)) +
#     scale_fill_viridis_c(option = "plasma", na.value = "grey50",
#                          limits = c(total_min, total_max)) +  # Definindo os limites da escala
#     labs(title = paste("Total de Templos por Condado - Ano", ano, "Estado", fips_estado),
#          fill = "Total de Templos") +
#     coord_sf(xlim = c(-170, -130), ylim = c(51, 71), expand = FALSE) +
#     theme_minimal()
#
#   print(mapa)
#
#   # Salvando o plot como PNG
#   ggsave(filename = file.path(output_dir, paste("mapa_tempos_", ano, "_estado_", fips_estado, ".png", sep = "")),
#          plot = mapa,
#          width = 10, height = 8, dpi = 300)
# }
#
# fips_estado <- "02"  # 02 é Código FIPS do Alaska
# anos_unicos <- unique(dados_condados$year)
#
#
# # Gerando e salvando mapas para cada ano, com a mesma escala de cores, para o estado escolhido
# for (ano in anos_unicos) {
#   resultado <- plot_map(dados_condados, ano, mapa_condados, output_directory, total_min, total_max, fips_estado)
#
#   # Verifica se o resultado é NULL e informa ao usuário
#   if (is.null(resultado)) {
#     message(paste("Nenhum mapa gerado para o ano:", ano))
#   }
# }
if(!require(ggplot2)){install.packages("ggplot2");require(ggplot2)}
if(!require(sf)){install.packages("sf");require(sf)}
if(!require(tmap)){install.packages("tmap");require(tmap)}
if(!require(haven)){install.packages("haven");require(haven)}
if(!require(dplyr)){install.packages("dplyr");require(dplyr)}
if(!require(stringr)){install.packages("stringr");require(stringr)}
if(!require(writexl)){install.packages("writexl");require(writexl)}
if(!require(tidyr)){install.packages("tidyr");require(tidyr)}
mapa_condados <- st_read("tl_2024_us_county\\tl_2024_us_county.shp")
dados <- read_dta("Bases_Tratadas\\Churches_USA_Data.dta")
# View(dados)
dados <- dados %>% group_by(fipsmerg) %>%
mutate(fipsmerg_original = ifelse(is.na(fipsmerg_original), first(fipsmerg_original[!is.na(fipsmerg_original)]), fipsmerg_original))
dados$fipsmerg <- str_pad(dados$fipsmerg_original, width = 5, pad = "0")
dados_condados <- dados %>%
group_by(fipsmerg, year, reltrad) %>%
summarize(total_templos = sum(congreg, na.rm = TRUE)) %>%
ungroup()
# Reestruturar os dados com pivot_wider
dados_condados_pivot <- dados_condados %>%
pivot_wider(names_from = reltrad, values_from = total_templos,
names_prefix = "reltrad_", values_fill = 0) %>%
mutate(predominante = case_when(
reltrad_1 > reltrad_2 & reltrad_1 > reltrad_3 ~ "Evangelical",
reltrad_2 > reltrad_1 & reltrad_2 > reltrad_3 ~ "Mainline",
reltrad_3 > reltrad_1 & reltrad_3 > reltrad_2 ~ "Católica",
TRUE ~ "Empate"  # Caso haja empate
))
plot_map <- function(dados, shapefile, ano, lim_lat, lim_lon, output_dir) {
# Filtrar dados para o ano específico
dados_ano <- dados %>% filter(year == !!ano)
# Fazer o join com o shapefile
dados_merged <- shapefile %>%
left_join(dados_ano, by = c("GEOID" = "fipsmerg"))
# Criar o plot
p <- ggplot(dados_merged) +
geom_sf(aes(fill = predominante), color = "white", size = 0.1) +
scale_fill_manual(values = c("Evangelical" = "lightblue",
"Mainline" = "lightgreen",
"Católica" = "pink",
"Empate" = "gray")) +
coord_sf(xlim = lim_lon, ylim = lim_lat) +
labs(title = paste("Denominação Predominante em", ano),
fill = "Denominação") +
theme_minimal()
# Salvar o plot
ggsave(filename = file.path(output_dir, paste("mapa_categoria_dominante_", ano, ".png", sep = "")),
plot = p, width = 8, height = 6)
}
output_directory <- "figuras"
# Definir limites dos EUA (ajustar se necessário)
lim_lat <- c(24, 50)
lim_lon <- c(-125, -66)
# Gerar os mapas para os anos de interesse
anos <- c(1980, 1990, 2000, 2010)
for (ano in anos) {
plot_map(dados_condados_pivot, mapa_condados, ano, lim_lat, lim_lon, output_directory)
}
############# DELETAR
#
# # Agrupar por condado e ano, e somar o número de templos
# dados_condados <- dados %>%
#   group_by(fipsmerg, year) %>%
#   summarize(total_templos = sum(congreg, na.rm = TRUE)) %>%
#   ungroup()
# # View(dados_condados)
# # dados_condados
# # write_xlsx(dados_condados, "outputs\\dados_condados.xlsx")
#
# # total_min <- min(dados_condados$total_templos, na.rm = TRUE)
# # total_max <- max(dados_condados$total_templos, na.rm = TRUE)
# total_min <- quantile(dados_condados$total_templos, 0.05, na.rm = TRUE)
# total_max <- quantile(dados_condados$total_templos, 0.95, na.rm = TRUE)
#
# # Truncando os valores da coluna 'total_templos' para ficar dentro dos percentis
# dados_condados <- dados_condados %>%
#   mutate(total_templos_ajustado = pmin(pmax(total_templos, total_min), total_max))
#
#
# # Definindo a função plot_map
# plot_map <- function(data, ano, shapefile, output_dir) {
#   # Filtrando os dados para o ano específico
#   dados_ano <- data %>% filter(year == ano)
#
#   # Unindo os dados de templos com o shapefile
#   mapa_dados <- shapefile %>%
#     left_join(dados_ano, by = c("GEOID" = "fipsmerg"))
#
#   # Verificando se a junção retornou dados
#   if (nrow(mapa_dados) == 0) {
#     warning(paste("Nenhum dado encontrado para o ano", ano))
#     return(NULL)  # Encerra a função se não houver dados
#   }
#
#   # Criando o mapa
#   mapa <- ggplot(data = mapa_dados) +
#     geom_sf(aes(fill = total_templos_ajustado)) +  # Preenchimento baseado na soma de templos
#     scale_fill_viridis_c(option = "plasma", na.value = "grey50",
#                          limits = c(total_min, total_max)) +  # Paleta de cores
#     labs(title = paste("Total de Templos por Condado - Ano", ano),
#          fill = "Total de Templos") +
#     coord_sf(xlim = c(-125, -65), ylim = c(25, 50), expand = FALSE) +  # Definindo os limites para focar nos EUA
#     theme_minimal()
#
#   print(mapa)
#
#   # Salvando o plot como PNG
#   ggsave(filename = file.path(output_dir, paste("mapa_tempos_", ano, ".png", sep = "")),
#          plot = mapa,
#          width = 10, height = 8, dpi = 300)
# }
#
# anos_unicos <- unique(dados_condados$year)  # Obtendo anos únicos
# output_directory <- "figuras"
#
# # Criando o diretório se não existir
# if (!dir.exists(output_directory)) {
#   dir.create(output_directory)
# }
#
# # Gerando e salvando mapas para cada ano
# for (ano in anos_unicos) {
#   resultado <- plot_map(dados_condados, ano, mapa_condados, output_directory)
#
#   # Verifica se o resultado é NULL e informa ao usuário
#   if (is.null(resultado)) {
#     message(paste("Nenhum mapa gerado para o ano:", ano))
#   }
# }
#
# ### PARA UM ESTADO ESPECIFICO
#
# # Definindo a função plot_map com filtragem por estado
# plot_map <- function(data, ano, shapefile, output_dir, total_min, total_max, fips_estado) {
#   # Filtrando os dados para o ano específico
#   dados_ano <- data %>% filter(year == ano)
#
#   # Filtrando o shapefile e os dados para o estado específico com base nos dois primeiros dígitos do código FIPS
#   shapefile_estado <- shapefile %>% filter(substr(GEOID, 1, 2) == fips_estado)
#   dados_ano_estado <- dados_ano %>% filter(substr(fipsmerg, 1, 2) == fips_estado)
#
#   # Unindo os dados de templos com o shapefile do estado
#   mapa_dados <- shapefile_estado %>%
#     left_join(dados_ano_estado, by = c("GEOID" = "fipsmerg"))
#
#   # Verificando se a junção retornou dados
#   if (nrow(mapa_dados) == 0) {
#     warning(paste("Nenhum dado encontrado para o ano", ano))
#     return(NULL)  # Encerra a função se não houver dados
#   }
#
#   # Criando o mapa focado no estado específico
#   mapa <- ggplot(data = mapa_dados) +
#     geom_sf(aes(fill = total_templos_ajustado)) +
#     scale_fill_viridis_c(option = "plasma", na.value = "grey50",
#                          limits = c(total_min, total_max)) +  # Definindo os limites da escala
#     labs(title = paste("Total de Templos por Condado - Ano", ano, "Estado", fips_estado),
#          fill = "Total de Templos") +
#     coord_sf(xlim = c(-170, -130), ylim = c(51, 71), expand = FALSE) +
#     theme_minimal()
#
#   print(mapa)
#
#   # Salvando o plot como PNG
#   ggsave(filename = file.path(output_dir, paste("mapa_tempos_", ano, "_estado_", fips_estado, ".png", sep = "")),
#          plot = mapa,
#          width = 10, height = 8, dpi = 300)
# }
#
# fips_estado <- "02"  # 02 é Código FIPS do Alaska
# anos_unicos <- unique(dados_condados$year)
#
#
# # Gerando e salvando mapas para cada ano, com a mesma escala de cores, para o estado escolhido
# for (ano in anos_unicos) {
#   resultado <- plot_map(dados_condados, ano, mapa_condados, output_directory, total_min, total_max, fips_estado)
#
#   # Verifica se o resultado é NULL e informa ao usuário
#   if (is.null(resultado)) {
#     message(paste("Nenhum mapa gerado para o ano:", ano))
#   }
# }
if(!require(ggplot2)){install.packages("ggplot2");require(ggplot2)}
if(!require(sf)){install.packages("sf");require(sf)}
if(!require(tmap)){install.packages("tmap");require(tmap)}
if(!require(haven)){install.packages("haven");require(haven)}
if(!require(dplyr)){install.packages("dplyr");require(dplyr)}
if(!require(stringr)){install.packages("stringr");require(stringr)}
if(!require(writexl)){install.packages("writexl");require(writexl)}
if(!require(tidyr)){install.packages("tidyr");require(tidyr)}
mapa_condados <- st_read("tl_2024_us_county\\tl_2024_us_county.shp")
dados <- read_dta("Bases_Tratadas\\Churches_USA_Data.dta")
# View(dados)
dados <- dados %>% group_by(fipsmerg) %>%
mutate(fipsmerg_original = ifelse(is.na(fipsmerg_original), first(fipsmerg_original[!is.na(fipsmerg_original)]), fipsmerg_original))
dados$fipsmerg <- str_pad(dados$fipsmerg_original, width = 5, pad = "0")
dados_condados <- dados %>%
group_by(fipsmerg, year, reltrad) %>%
summarize(total_templos = sum(congreg, na.rm = TRUE)) %>%
ungroup()
# Reestruturar os dados com pivot_wider
dados_condados_pivot <- dados_condados %>%
pivot_wider(names_from = reltrad, values_from = total_templos,
names_prefix = "reltrad_", values_fill = 0) %>%
mutate(predominante = case_when(
reltrad_1 > reltrad_2 & reltrad_1 > reltrad_3 ~ "Evangelical",
reltrad_2 > reltrad_1 & reltrad_2 > reltrad_3 ~ "Mainline",
reltrad_3 > reltrad_1 & reltrad_3 > reltrad_2 ~ "Católica",
TRUE ~ "Empate"  # Caso haja empate
))
plot_map <- function(dados, shapefile, ano, lim_lat, lim_lon, output_dir) {
# Filtrar dados para o ano específico
dados_ano <- dados %>% filter(year == !!ano)
# Fazer o join com o shapefile
dados_merged <- shapefile %>%
left_join(dados_ano, by = c("GEOID" = "fipsmerg"))
# Criar o plot
p <- ggplot(dados_merged) +
geom_sf(aes(fill = predominante), color = "white", size = 0.1) +
scale_fill_manual(values = c("Evangelical" = "#1f78b4",
"Mainline" = "#33a02c",
"Católica" = "#e31a1c",
"Empate" = "#6a3d9a")) +
coord_sf(xlim = lim_lon, ylim = lim_lat) +
labs(title = paste("Denominação Predominante em", ano),
fill = "Denominação") +
theme_minimal()
# Salvar o plot
ggsave(filename = file.path(output_dir, paste("mapa_categoria_dominante_", ano, ".png", sep = "")),
plot = p, width = 8, height = 6)
}
output_directory <- "figuras"
# Definir limites dos EUA (ajustar se necessário)
lim_lat <- c(24, 50)
lim_lon <- c(-125, -66)
# Gerar os mapas para os anos de interesse
anos <- c(1980, 1990, 2000, 2010)
for (ano in anos) {
plot_map(dados_condados_pivot, mapa_condados, ano, lim_lat, lim_lon, output_directory)
}
############# DELETAR
#
# # Agrupar por condado e ano, e somar o número de templos
# dados_condados <- dados %>%
#   group_by(fipsmerg, year) %>%
#   summarize(total_templos = sum(congreg, na.rm = TRUE)) %>%
#   ungroup()
# # View(dados_condados)
# # dados_condados
# # write_xlsx(dados_condados, "outputs\\dados_condados.xlsx")
#
# # total_min <- min(dados_condados$total_templos, na.rm = TRUE)
# # total_max <- max(dados_condados$total_templos, na.rm = TRUE)
# total_min <- quantile(dados_condados$total_templos, 0.05, na.rm = TRUE)
# total_max <- quantile(dados_condados$total_templos, 0.95, na.rm = TRUE)
#
# # Truncando os valores da coluna 'total_templos' para ficar dentro dos percentis
# dados_condados <- dados_condados %>%
#   mutate(total_templos_ajustado = pmin(pmax(total_templos, total_min), total_max))
#
#
# # Definindo a função plot_map
# plot_map <- function(data, ano, shapefile, output_dir) {
#   # Filtrando os dados para o ano específico
#   dados_ano <- data %>% filter(year == ano)
#
#   # Unindo os dados de templos com o shapefile
#   mapa_dados <- shapefile %>%
#     left_join(dados_ano, by = c("GEOID" = "fipsmerg"))
#
#   # Verificando se a junção retornou dados
#   if (nrow(mapa_dados) == 0) {
#     warning(paste("Nenhum dado encontrado para o ano", ano))
#     return(NULL)  # Encerra a função se não houver dados
#   }
#
#   # Criando o mapa
#   mapa <- ggplot(data = mapa_dados) +
#     geom_sf(aes(fill = total_templos_ajustado)) +  # Preenchimento baseado na soma de templos
#     scale_fill_viridis_c(option = "plasma", na.value = "grey50",
#                          limits = c(total_min, total_max)) +  # Paleta de cores
#     labs(title = paste("Total de Templos por Condado - Ano", ano),
#          fill = "Total de Templos") +
#     coord_sf(xlim = c(-125, -65), ylim = c(25, 50), expand = FALSE) +  # Definindo os limites para focar nos EUA
#     theme_minimal()
#
#   print(mapa)
#
#   # Salvando o plot como PNG
#   ggsave(filename = file.path(output_dir, paste("mapa_tempos_", ano, ".png", sep = "")),
#          plot = mapa,
#          width = 10, height = 8, dpi = 300)
# }
#
# anos_unicos <- unique(dados_condados$year)  # Obtendo anos únicos
# output_directory <- "figuras"
#
# # Criando o diretório se não existir
# if (!dir.exists(output_directory)) {
#   dir.create(output_directory)
# }
#
# # Gerando e salvando mapas para cada ano
# for (ano in anos_unicos) {
#   resultado <- plot_map(dados_condados, ano, mapa_condados, output_directory)
#
#   # Verifica se o resultado é NULL e informa ao usuário
#   if (is.null(resultado)) {
#     message(paste("Nenhum mapa gerado para o ano:", ano))
#   }
# }
#
# ### PARA UM ESTADO ESPECIFICO
#
# # Definindo a função plot_map com filtragem por estado
# plot_map <- function(data, ano, shapefile, output_dir, total_min, total_max, fips_estado) {
#   # Filtrando os dados para o ano específico
#   dados_ano <- data %>% filter(year == ano)
#
#   # Filtrando o shapefile e os dados para o estado específico com base nos dois primeiros dígitos do código FIPS
#   shapefile_estado <- shapefile %>% filter(substr(GEOID, 1, 2) == fips_estado)
#   dados_ano_estado <- dados_ano %>% filter(substr(fipsmerg, 1, 2) == fips_estado)
#
#   # Unindo os dados de templos com o shapefile do estado
#   mapa_dados <- shapefile_estado %>%
#     left_join(dados_ano_estado, by = c("GEOID" = "fipsmerg"))
#
#   # Verificando se a junção retornou dados
#   if (nrow(mapa_dados) == 0) {
#     warning(paste("Nenhum dado encontrado para o ano", ano))
#     return(NULL)  # Encerra a função se não houver dados
#   }
#
#   # Criando o mapa focado no estado específico
#   mapa <- ggplot(data = mapa_dados) +
#     geom_sf(aes(fill = total_templos_ajustado)) +
#     scale_fill_viridis_c(option = "plasma", na.value = "grey50",
#                          limits = c(total_min, total_max)) +  # Definindo os limites da escala
#     labs(title = paste("Total de Templos por Condado - Ano", ano, "Estado", fips_estado),
#          fill = "Total de Templos") +
#     coord_sf(xlim = c(-170, -130), ylim = c(51, 71), expand = FALSE) +
#     theme_minimal()
#
#   print(mapa)
#
#   # Salvando o plot como PNG
#   ggsave(filename = file.path(output_dir, paste("mapa_tempos_", ano, "_estado_", fips_estado, ".png", sep = "")),
#          plot = mapa,
#          width = 10, height = 8, dpi = 300)
# }
#
# fips_estado <- "02"  # 02 é Código FIPS do Alaska
# anos_unicos <- unique(dados_condados$year)
#
#
# # Gerando e salvando mapas para cada ano, com a mesma escala de cores, para o estado escolhido
# for (ano in anos_unicos) {
#   resultado <- plot_map(dados_condados, ano, mapa_condados, output_directory, total_min, total_max, fips_estado)
#
#   # Verifica se o resultado é NULL e informa ao usuário
#   if (is.null(resultado)) {
#     message(paste("Nenhum mapa gerado para o ano:", ano))
#   }
# }
